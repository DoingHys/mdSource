[TOC]



# 关系型数据库

需要掌握点：架构、索引、锁、语法、理论范式



## 如何设计一个关系型数据库：

要设计一个关系型数据库，首先我们要知道数据库的功能是什么，就是存储我们的数据，因此他会有一个存储模块  （文件系统）来存储我们的数据，存储模块就类似我们的os文件系统将数据最终持久化存入磁盘中，如存入机械硬盘，ssd固态硬盘或者他们的磁盘分类矩阵中，可是光有存储是不行的，我们还需要组织并且用到这些数据，因此我们还需要有 **程序实例**，用逻辑结构映射出物理结构来，并且在程序中提供获取以及管理的方式，还有必要的问题追踪机制；那么我就要细分下程序的模块，首先我们要对数据的格式以及文件的分隔进行统一的管理，及把物理数据通过逻辑的形式给组织和表示出来 ，于是便涉及到了程序的**存储模块**；为了使读取性能更大，引入了缓存机制，通过把取出的数据块存放到缓存中，下次需要的时候直接从内存返回而不用发生io从而优化了访问效率；接下来我们还要提供给外界指令来操作我们的数据库及可读的sql语言，那么我们就需要一个**sql的解析模块**，将sql编译解析转化为机器可识别的指令，为了提升sql的执行效率，我们可以把sql缓存到缓存里，那么便宜好的sql，方便下次来了直接进行解析就可以；接着我们操作数据需要把这些操作记录下来，方便我们接下来做的主从同步和灾难恢复，因此我们就需要由**日志管理模块** ，去对我们的操作记录做记录；再者 ，我们还要提供给用户管理数据的私密空间，及权限划分，通俗的讲，就是让老板能看到员工的数据，员工只能看到自己的数据，因此需要一个**权限划分模块**,而这通常是dba做的事情，而不需要我们过多关心；涉及系统的时候，除了考虑正常的功能，还需要考虑异常的情况，那么去处理异常情况我们需要引入一个**容灾机制**,当我们数据挂了，该怎么恢复， 恢复到什么程度，这些都需要设计；除此外，为了能进一步提升查询数据的速度以及让数据库支持并发，我们还需要引入最能突出数据库特点的两个模块，也就是**索引模块**和 **锁管理模块**（重中之重）



## 索引模块

* **为什么使用索引**

  我们在日常开发中会发现，我们一般会使用全表扫描这种简单的方式的查询数据，它会把整张表的数据全部或者分批次加载到内存当中，那么数据存储的最小单位是块或者页，它们是由多行数据进行组成的，我们要查询想要的数据会不断的对这些块进行轮询不断的查找我们想要的目标并返回，这种方式普遍会被认为非常慢的，但是存在即合里，当只有少量数据直接加载到内存里进行全表扫描肯定是比使用索引查询要快的，但是当在数据量很大的表里面查询这样是很慢的，因此很多情况下我们都要比面全表扫描 的情况发生，所以我们的数据库要引入更高效的机制，这便是索引了；通过索引我们能更快定位到数据的位置，大幅度提升我们的查询速度（简单回答）

* **什么样的信息能成为索引**

  主键，唯一键以及普通键等

* **索引的数据结构**

  生成索引，建立二叉查找树进行二分查找

  建立B-Tree结构进行查找

  建立B+-Tree树 结构进行查找（mysql的索引实现）

  建立hash结构进行查找

* **密集索引及稀疏索引的区别**

* **优化索引~二叉查找树**

  虽然使用二叉查找树能优化索引，但是每次读取一块数据到节点上都会发生一次io，这样树的深度增加一就会相对应增加一次iO，当深度也深时,从而会降低了索引的效率

* **优化索引~B-Tree**

  ![image-20200627152239244](C:\Users\vinti\AppData\Roaming\Typora\typora-user-images\image-20200627152239244.png)

  因此我们不只要降低查询复杂度，还要降低io次数，因此就引入B-Tree，他每次io能同步更多数据都缓存块，而且每次增删节点会使用相应的策略使得树处于平衡的状态而不会转化为线性结构;

  B-Tree,又称为平衡多路查找树；如果每个节点最多又n个孩子，那么这个树就叫做**M**阶**B-Tree;

  B-Tree的每个存储块中主要包含了关键字，和指向孩子 的指针 ，那么最多能有几个孩子取决于存储块的容量以及数据库的相关配置，所以通常情况下这个 **M**是很大的

  **B-Tree 的定义**：

  - 根节点至少包含2个孩子
  - 树中每个节点的最多含有M个孩子（M>=2）{也就是孩子要 大于2小于3}
  - 除根节点和叶节点外，其他每个节点至少有ceil（m/2）个孩子【例如3/2=2,取上限】
  - 所有叶子节点都是同一层 

* **优化索引~B+~Tree**

  ![image-20200627155122020](C:\Users\vinti\AppData\Roaming\Typora\typora-user-images\image-20200627155122020.png)

  B+-树是B-树的变体， 其定义基本与B树相同，除了：

  * 非叶子节点的子树指针与关键字个数相同
  * 非叶子节点的子树指针P[i],指向关键字值[K[i],k[i+1]）的子树 k[i]<=x<k[i+1]
  * 非叶子节点只用来做索引，数据都bao存在叶子节点中【ps：b+树所有的检索都是从根部开始，检索到叶子节点才能结束，同时非叶子节点仅用来存储索引，非叶子节点不存储数据的话又能存储更多的关键字了，那也就是使得B+树相对于B树来说更矮，对于搜获能在任意一个非叶子节点中止掉了，也就是能把数据文件存储在非叶子节点上】
  * 所有叶子节点均有一个链指针指向下一个叶子结点，并按大小顺序链接【ps:这样能方便我们在叶子节点中做范围统计 】

* **哪种树作为索引设计更优**

  综上所述：B+Tree更适合用来作存储索引,原因如下

  1. B+树的磁盘独写代价更低：B+树的内部结构并没有 指向关键字的具体信息的指针，也就是不存放我们的数据，只存放索引信息，因此，其内部节点相对B树更小，如果把所有的同一内部节点的关键字存放在同一盘块中，这个盘块所能容纳的关键字数量野就越多，一次性读入内存中的需要查找的关键字野就越多，相对来说，io读写次数也就降低了
  2. B+树的查询效率更加稳定：由于内部节点并不是最终指向文件内容的节点，而只是叶子节点中关键字的索引，所以任何关键字的查找必须走一条从根节点到叶子节点的路，所有关键字查询的长度相同，导致每一个数据的查询效率也几乎时相同也就是稳定的O(logN)
  3. B+树更有利于对数据库的扫描：B树在提高了磁盘io性能的同时并没有提高元素遍历的性能，而B+树只需要遍历叶子节点就可以解决对全部关键字信息的扫描，所以对于数据库中频繁使用的范围查询是非常方便的

  以上便是我们为什么使用B+树作为主流索引数据结构的原因

* Hash索引的里了解

  hash索引的查询性能理论要高于hash索引，因为理想的情况下，它的查询时间复杂度是O(1),例如我们要查询一个关键字为A的数据，首先要计算A的hash值，定位到它所所在的bucket，然后讲该桶的enrty(链表)同步到内存；在这里也许有人会疑惑既然hash索引查询效率要比B+树高，那为什么不拿hash索引作为主流索引呢？任何事物都有两面性，虽然它查询效率高，但是它也是有一些自身缺点：

  1. 仅仅能满足 “=”，“IN“ ,不能使用范围查询（ps:因为hash索引比较的是进行hash运算的hash值，所以它只能用宇等值的过滤，不能基于范围的查询,因为进行运算后的hash值大小并不能和运算前的大小保持一致)
  2. 无法被用来进行数据的排序操作（ps:因为进行运算后的hash值大小并不能和运算前的大小保持一致,所以数据库不能通过hash后的值进行排序运算）
  3. 不能利用部分索引键去做查询（ps:对于组合索引，hash索引在进行hash值得时候如果发现是组合键，则会将组合建合并之后再一期进行运算的 hash值而不是单独计算hash值，所以通过组合索引的前面一个或几个进行查询的时候，hash索引也无法被利用，而B+-Tree是支持组合索引中的部分索引的）
  4. 不能避免表扫描（ps:对于hash冲突的键信息，需要对链表进行扫描）
  5. 遇到大量Hash值相等的情况后性能不一定会比B+-Tree索引要高（可能会变成线性存储结构，这也是hash索引不能成为主流索引的原因，因为它比较不稳定，不支持范围的查询）

* BitMap索引是个神器

* 密集索引和稀疏索引的区别：

  1. 密集索引文件中的每个搜索码值都对应一个索引值
  2. 稀疏索引文件只为索引码的某些值建立索引项

  
  
##  文件结构

  innodb：包含两个文件，分别是 ：.frm和.ibd 文件

  myisam：包含三个文件，分别是：.frm、.myi、.MYD文件

  其中：.frm是存储表结构信息；数据和索引是存贮在ibd文件下（innodb）；对myisam，索引是存在myi下的，数据是存在myd下的





# 主要问题
### 为什么使用索引?
因为索引能让我们避免全表扫描去查找数据，去提升检索效率

### 什么样的信息能成为索引？
主键，唯一键等能让数据具备一定区分性的字段都能成为索引

### 索引的数据结构？
主流是B+树，还有B树，hash结构以及bitMap等，其中mysql数据库不支持bitMap,同时基于innodb以及myisam引擎的mysql不显示支持hash 

### 密集索引和稀疏引的区别

### 如何定位并且优化慢查询sql
1. 根据慢日志定位慢查询
	所谓慢日志就是用来记录我们执行比较慢的sql,我们可以通过show variables like '%quer%';这条脚本来查询出相关的变量来，这时候我们要着重关注 几个变量，分别时show_query_log(默认off,我们需要将它打开)，另外一个是show_query_log_file(记录慢sql的路劲)，还有就是long_query_time(默认10 秒)；也就是当一条sql 执行l超过10秒钟（long_query_time ）的时候，它就会被记录到show_query_log_file的路径下；那么了解了变量我们还需要去了解状态，有个指令是叫做 show status like '%slow_queries%',通过执行它我们能够知道慢查询的数量，也就是说但我们有一条sql达到慢查询指标时，它就是1；那么我们就可以通过set global slow_query_log=on;就能打开慢查询记录开关了，还有通过set global long_query_time=1 就能设置慢查询时间；通过这样设置以后就可以通过重新连接客户端来看到设置的变化；或者我们也可以在my.cnf（linux）或者my.ini(windows)这个配置文件来对这些值进行永久设置
【这个可以结合项目来说，例如拼团项目的开团量 （统计不同团类别的开团量），发现是查询响应慢，然后渠道慢日志目录文件查看对应的sql,然后相对应的对这条sql进行调优，那么我们就可以通过explain来分析这条sql的查询性能，通过explain我们能知道查询低效的原因从而进行改进这条sql】
2. 使用explain等工具进行sql分析
我们可以获取慢日志的慢sql，然后在sql 前面进行explain 查询sq，然后执行这条sql,执行后我们会发现有多列的结果，其中包括 {id，select_type,table,type,rows,key,fileted,extra} 等 ，其中我们只需要关心一些核心的字段就行，例如，id是标明了sql的执行顺序，id越大就越先执行；type:表示mysql找到需要的数据行的方式，方式有很多，例如 system>const>....range>index>all等，其中index，all表明本次查询走的是全表扫描，因此当我们看到type是这两个的其中之一时，一般都需要进行优化；extra：我们可以通过它了解更多信息，这里表示的类型也很多，那我们也只需要关注其中两种方式，分别是using filesort 和using temporary,其中using filesort表示mysql会对结果使用一个外部索引进行排序而不是从表里按索引次序读到相关的内容，可能在内存或者磁盘上进行排序。mysql中无法利用索引完成的排序操作称为“文件排序”，using tempory :表示mysql在对查询结果进行排序时使用临时表,常见于排序order by 和分组查询group by; 一般出现这两种类型的时候也表示查询是比较慢的，需要进行调优语句了；
3. 修改sql或者让sql尽量走索引，进而提升检索效率

#### 记录：
**为什么select(*)不走密集索引**
mysql查询优化器 可以决定走那个索引，它最重要的目标是尽可能的使用索引并且 使用最严格的索引来消除尽可能多的数据行 ，最终目标是提交select语句查询数据行而不是排除数据行；它一般不选择主键索引大致是因为密集索引的叶子节点把其他列的数据也存放了叶子节点中，这样它的效率会比稀疏索引要低，因为稀疏索引只存储了关键字以及主键的值，这样子我们在内存中就能加载到更多的关键字和主键的值来做这个cout(*)

**force index(index_key) 可以测试各种索引**
例如 select count(id) from tb force index(primary) 能强制走主键索引

### 联合索引最左匹配原则的成因

### 索引是建立越多越好吗4


