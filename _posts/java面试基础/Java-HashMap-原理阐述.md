[TOC]



# 1.原理概述

hash 是指将一个任意长度通过某种算法（hash函数）转换成一个固定的值；

map是指 地图，（x，y）存储

总结：HashMap 指通过hash出来的值，然后定位到这个Map中去，然后value存到这个map中

初始化容量：1左移4位=16位

默认最大容量：1左移30位

加载因子：0.75；1分四等分，0.25*3=0.75（3/4），在容量的（3/4）时候扩容



## ^ 作用

异或，就是转化为二进制后相对位比较，相同的为0不同的为1



## >>>20

是转化为二进制右移位，空出来的补0



# 2.HashMap的长度为什么总是2的幂次方

为了使hashMap的存取更高效，那么要尽量少的减少hash碰撞，也就是要把元素分配的尽量均匀，那么这里是通过对得出的hashCode 的高16位和低16位进行异或运算实现的，这样得出来的值得范围是在负21亿和正21亿之间得，前后加起来大概有40亿得空间;一般这样能使得哈希函数散列度更高，更低概率的出现哈希碰撞，但是问题是一个40亿长度的数组，内存是放不下的，所以这个散列值不能直接拿来用。用之前需要对数组的长度进行取模运算，得出的余数才能用来做存放的位置，也就是对应的数组下标。这个获取数组的下标的计算方式就是“（length-1）&hash”,length代表数组的长度。这也就解释了为什么Hash的长度要保证位2的幂次方；

因为有这样一个算法是， **hash%length==hash&(length-1)**，前提是length是2的次方幂；相对于%，这样的位操作更能提高运算效率



## JDK1.7 VS JDK1.8 比较

优化概述：

1. resize 扩容优化
2. 引入了红黑树，目的是避免单条链表过长而影响查询效率
3. 解决了resize时多线程死循环问题，但仍是非线程安全的



## 参考文章

https://www.cnblogs.com/twoheads/p/10682275.html

https://www.cnblogs.com/dangdingmanong2333/p/9782670.html

jdk1.7，引起死循环问题

https://blog.csdn.net/qq_25026989/article/details/89527782

jdk1.8解决死循环得问题

https://my.oschina.net/alexqdjay/blog/1377268



# 总结

不足性：

1.时间复杂度，差的情况可能会很差，hash算法决定了效率，因为，当元素越来越多的时候，hash冲突问题会很明响，这时候链表的长度也会越来越长，所以当查询一个元素，链表长度很长的时候，遍历查找导致的时间复杂度也会很大



2.每当hashMap进行扩容的时候，需要重新去添加元素对象，需要重新Hash,然后存放到 Node[] table里面去，所以当工作中，如果你知道你容器所需要的大小，最好先指定HashMap的初始容量，尤其是容量很大的时候，这样可以防止HashMap进行再次扩容

