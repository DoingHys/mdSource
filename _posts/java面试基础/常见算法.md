# 算法复杂度

**时间复杂度：**
  一般情况下，算法中基**本操作重复执行的次数**是问题规模n的某个函数f(n)，进而分析f(n)随n的变化情况并确定T(n)的数量级。这里用"O"来表示数量级，给出算法的时间复杂度。
                     T(n)=O(f(n));
  它表示随着问题规模的n的增大，算法的执行时间的增长率和f(n)的增长率相同，这称作算法的渐进时间复杂度，简称时间复杂度。而我们一般讨论的是最坏时间复杂度，这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的上界，分析最坏的情况以估算算法指向时间的一个上界。

时间复杂度的分析方法：
1、时间复杂度就是函数中基本操作所执行的次数
2、一般默认的是最坏时间复杂度，即分析最坏情况下所能执行的次数
3、忽略掉常数项
4、关注运行时间的增长趋势，关注函数式中增长最快的表达式，忽略系数
5、计算时间复杂度是估算随着n的增长函数执行次数的增长趋势
6、递归算法的时间复杂度为：递归总次数 * 每次递归中基本操作所执行的次数

    常用的时间复杂度有以下七种，算法时间复杂度依次增加：O(1)常数型、O(log2 n)对数型、O(n)线性型、O(nlog2n)二维型、O(n^2)平方型、O(n^3)立方型、O(2^n)指数型.
![img](https://img-blog.csdn.net/20160906202554825?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)



**空间复杂度:**

  算法的空间复杂度**并不是计算实际占用的空间，而是计算整个算法的辅助空间单元的个数**，与问题的规模没有关系。算法的空间复杂度S(n)定义为该算法所耗费空间的数量级。
  S(n)=O(f(n))  若算法执行时所需要的辅助空间相对于输入数据量n而言是一个常数，则称这个算法的辅助空间为O(1); 
  递归算法的空间复杂度：递归深度N*每次递归所要的辅助空间， 如果每次递归所需的辅助空间是常数，则递归的空间复杂度是 O(N).








# 冒泡排序

1. 参考博客：https://blog.csdn.net/zcl_love_wx/article/details/83576962

2. 原理：假如对n个数进行由小到大冒泡排序，使用两层嵌套循环 进行冒泡排序，外层遍历n-1次

   内层每次遍历从第0个元素开始，和下一个元素进行比较，值较大的一位向上冒泡；这样，一次内外遍历以后最大值会冒泡到顶端；此时，内层循环就可以减少一次且本身比较也减少一次，即n-1-i；遍历完以后即实现了冒泡排序；

3. 时间复杂度：

    这个时间复杂度还是很好计算的：外循环和内循环以及判断和交换元素的时间开销；

          最优的情况也就是开始就已经排序好序了，那么就可以不用交换元素了，则时间花销为：[ n(n-1) ] /  2；所以最优的情况时间复杂度为：O( n^2 )；
           
          最差的情况也就是开始的时候元素是逆序的，那么每一次排序都要交换两个元素，则时间花销为：[ 3n(n-1) ] / 2；（其中比上面最优的情况所花的时间就是在于交换元素的三个步骤）；所以最差的情况下时间复杂度为：O( n^2 )；
           
           综上所述：
           
          最优的时间复杂度为：O( n^2 ) ；有的说 O(n)，下面会分析这种情况；
           
          最差的时间复杂度为：O( n^2 )；
           
          平均的时间复杂度为：O( n^2 )；

   

4. 空间复杂度：

     ***\*空间复杂度就是在交换元素时那个临时变量所占的内存空间；\****

      ***\*最优的空间复杂度就是开始元素顺序已经排好了，则空间复杂度为：0；\****

      ***\*最差的空间复杂度就是开始元素逆序排序了，则空间复杂度为：O(n)；\****

      ***\*平均的空间复杂度为：O(1)；\****

每走一趟减少一次，外部循环躺数，内部循环次数

最初版：嵌套循环

优化版：减少次数

最终版：设置有序标志为，减少遍历躺数

# 二分查找法

1. **原理：**

   对一个有序的数组进行二分查找，首位元素下标为left,末位元素下标为right ，中位数下标为mid，也就是每次找出数组的中位数a[mid],与需要查找的值target进行大小比较，如果target>a[mid],则证明target 在a[mid+1]~a[right]范围内，反之，则证明target 在 a[left]~a[mid-1]范围内；这样递归查找下去，最后target既不大于也不小于 a[mid]则可找出target值所对应的下标；

2. **代码**

   ```
   递归
   int binarysearch(int array[], int low, int high, int target) {
       if (low > high) return -1;
       int mid = low + (high - low) / 2;
       if (array[mid] > target)
           return binarysearch(array, low, mid - 1, target);
       if (array[mid] < target)
           return binarysearch(array, mid + 1, high, target);
       return mid;
   }
   
   非递归
   int bsearchWithoutRecursion(int a[], int key) {
       int low = 0;
       int high = a.length - 1;
       while (low <= high) {
           int mid = low + (high - low) / 2;
           if (a[mid] > key)
               high = mid - 1;
           else if (a[mid] < key)
               low = mid + 1;
           else
               return mid;
       }
       return -1;
   }
   ```

3. **二分查找中值的计算**

   这是一个经典的话题，如何计算二分查找中的中值？大家一般给出了两种计算方法：

   - 算法一： `mid = (low + high) / 2`
   - 算法二： `mid = low + (high – low)/2`

   乍看起来，算法一简洁，算法二提取之后，跟算法一没有什么区别。但是实际上，区别是存在的。算法一的做法，在极端情况下，(low + high)存在着溢出的风险，进而得到错误的mid结果，导致程序错误。而算法二能够保证计算出来的mid，一定大于low，小于high，不存在溢出的问题。

   

4. **二分查找法的缺陷**
   二分查找法的O(log n)让它成为十分高效的算法。不过它的缺陷却也是那么明显的。就在它的限定之上：必须有序，我们很难保证我们的数组都是有序的。当然可以在构建数组的时候进行排序，可是又落到了第二个瓶颈上：它必须是数组。

   数组读取效率是O(1)，可是它的插入和删除某个元素的效率却是O(n)。因而导致构建有序数组变成低效的事情。

   解决这些缺陷问题更好的方法应该是使用二叉查找树了，最好自然是自平衡二叉查找树了，既能高效的（O(n log n)）构建有序元素集合，又能如同二分查找法一样快速（O(log n)）的搜寻目标数。

   

5. **时间复杂度**

   假使总共有n个元素，那么二分后每次查找的区间大小就是n，n/2，n/4，…，n/2^k（接下来操作元素的剩余个数），其中k就是循环的次数。 
   最坏的情况是K次二分之后,每个区间的大小为1,找到想要的元素 
   令n/2^k=1， ===>   **n=2^k**;
   可得k=log2n,（是以2为底，n的对数），所以时间复杂度可以表示O()=O(logn).
