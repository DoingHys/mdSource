# 乐观锁与悲观锁

**悲观锁:**

每次假设最坏的情况，每次去拿数据时都认为别人会修改，所以每次拿数据都会上锁，这样当其他人想拿这个数据就会被阻塞直到它拿到锁（共享资源每次只给一个线程使用，其他线程会被阻塞，用完后再把资源转让给其他线程）。传统的关系型数据库就用了很多锁机制，包括行锁，表锁，读锁，写锁，都是在操作之前上锁的。java 中的synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。

**乐观锁：**

总是假设最好的情况，每次去拿数据都会觉得别人不会修改，所以不会上锁，但是在更新的时候会判断一下别人有没有更新这个数据，可以使用版本号几制和**CAS**算法实现。**乐观锁多应用于读**的场景，这样可以提高吞吐量。像数据库提供的write_condition 机制，其实都是提供的乐观锁。。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。

**比较：**

上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。

**版本号机制：**

一般在数据表中加上一个version字段，标识版本号，表示数据被修改的次数，当数据被修改时，version会加一。当线程A要更新数据时，读取数据会把版本号读出来，在提交数据时，若加一后的version大于数据库的version才update,否则重试update操作，知道update成功

**CAS算法：**

