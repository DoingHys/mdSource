# 对象被判定为垃圾的标准

* 对象没有被其他对象引用



# 判断对象是否为垃圾的算法

* 引用计数算法（主流jvm不用）

  1. 通过判断对象的引用数量来决定对象是否我可以被回收
  2. 每个对象实例都有一个引用计数器，被引用则+1，当对象实例的某个引用 超过了它的生命周期或者被设置为一个新值时  则实例计数器会-1
  3. 任何引用计数为0的对象实例可以被当作垃圾收集   

   优势：执行效率高，程序执行受影响较小；采用该算法可以过滤出引用计数器为0的对象，将其内存回收即可。它可以交织在程序运行中；由于垃圾回收的时候可以做到几乎不打断程序的执行，因此对程序需要不会长时间打断的环境比较有利 ；

  缺点：无法检测出循环引用的情况而导致内存泄漏（相互引用，计数器永远不为0就无法被回收）；

* 可达分析算法

  通过判断对象的引用链是否可达来决定对象是否可以被回收，从Gc ROot对象开始遍历，其余不能遍历到达的对象则是可以作为垃圾回收的对象

  可以作为GC root的对象有：虚拟机栈中引用的对象（栈帧中的本地变量表）；方法区中引用的常量引用对象  ，该常量保存的是某个对象的地址，被保存的对象也成为了根对象；方法区中的类静态属性引用的对象；本地方法栈中JNI的引用对象；活跃线程的引用对象

  

  # 谈谈你了解的垃圾回收算法

  **标记-清除算法:**

  

  

  

  

    

  



