# JVM内存模型 （jdk8）

对于jvm的内存模型可以从线程私有及线程共享两方面 去描述，线程私有的内存区包括 程序计数器，java虚拟机栈，本地方法栈；线程共享内存区域包括 MetaSpace （类加载信息）,java堆（常量池）；



# 1.虚拟机栈

是Java方法执行的内存模型，是线程私有的；每个方法的执行都会创建一个栈帧及方法运行时的数据结构，栈帧用于存储局部变量表，操作栈 ，动态链接，返回地址 等；方法的执行开始到结束对应着入栈到出栈这个过程；当方法执行结束后对应的栈帧也会被销毁

**局部变量表**

包含方法执行过程的所有变量

**操作数栈**

入栈、出栈、交换、赋值、产生消费变量

## 局部变量及操作数栈如何交互

![image-20200728010521124](C:\Users\vinti\AppData\Roaming\Typora\typora-user-images\image-20200728010521124.png)

**局部变量列表是为操作数栈提供数据支撑**



## 递归为什么会引发 Java.lang.StackOverflowError异常

因为每次递归都会调用一次自身去创建一个栈帧压入到虚拟机栈中，由于递归过深，压入虚拟机栈的栈帧数越来越多，最终导致栈帧的深度会超过虚拟机的深度，从而引发stackOverflow异常；

解决这个问题的方案可以限制递归的次数，或者直接使用循环的方法去替换递归；



## 虚拟机栈过多会引发java.lang.OutOfMemoryError

当虚拟机栈可以动态扩展时，如果无法申请足够多的内存就会英法OOM异常



## 为什么虚拟机栈内存不需要gc去回收

因为在我们编写代码的时候，没调用一个方法，虚拟机都会为这个方法分配一块空间，这块空间就是栈帧了；这个栈帧的空间会随着方法的调用完毕而被释放，因此这也是我们说的栈的内存不需要通过gc去回收而会自动释放的原因了；



# 2. 本地方法栈

与虚拟机栈相似，主要作用是服务于native的方法



# 3.程序计数器

是一块较小的内存空间，它的作用是可以当作当前线程所执行字节码的行号指示器，在虚拟机内存模型里，字节码解析器工作时，就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，包括分支，循环，跳转，异常处理，线程恢复等基础功能都需要依赖这个计数器来完成；由于jvm的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确认的时刻，一个处理器只会执行一条线程中的一个指令，因此为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器；各条线程之间的计数器互不影响，独立存储，我们称之为线程私有的内存；如果执行的是java方法，则记录的是虚拟机字节码指令的地址；如果正在执行的是nativef方法这个计数器值为undefined;此外由于只记录行号，程序计数器不需要担心内存泄漏的问题；



# 4.元空间（Meta Space）和永久代(permGen space)的区别

**备注：元空间和永久代均是方法区的实现**，只是实现有所不同，方法区只是jvm的规范，java7以后，原先位于方法区里面的字符串常量池已被移动到了java堆中，并且在jdk8后字使用了元空间替代了永久代



区别：

元空间使用本地内存，而永久代使用的是jvm内存；使用本地内存的元空间就不需要担心permGen space 的OOM异常了，因为本地内存有多少，元空间的内存就有多大，这解决了空间不足的问题，不过也不可能放任其无限壮大，jvm在运行的是侯会根据需要动态设计其大小；

## MetaSpace 相比PermGen 的优势

* 字符串常量池存在永久代中，容易出现性能问题和内存溢出
* 类和方法的信息大小难以确定，给永久代的大小指定带来困难，太小容易出现永久代溢出，太大则容易导致老年代溢出
* 永久代会为Gc带来不必要的复杂度，并且回收效率偏低



# 5. java堆

* 对象实例的分配区域
* GC管理的主要区域



# 常见问题：

## JVM三大性能调优参数-Xms,-Xmx -Xss的含义

分析一下:java -Xms128m -Xmx128m -Xss265 -jar xxxx.jar

**-Xss:**是指设定每个线程的堆栈大小。这个就要依据你的程序，看一个线程大约需要占用多少内存，可能会有多少线程同时运行等。？todo

 **-Xms:**堆的初始内存，及该线程刚创建出来的时候他的专属java堆大小，一旦超过了该值 会进行扩容，直至扩容到-Xmx

**-Xmx:**Java堆内存能扩展到的最大值

一般会将 -Xms 和-Xmx 设置为一样的大小，因为当heap不够用进行扩展时，会发生内存抖动，影响程序的稳定性



## java内存模型中堆和栈的区别（内存分配策略）

管理方式：栈自动释放，堆需要gc

空间大小：栈比堆小

碎片相关：栈产生的碎片远小于堆

分配方式：栈支持静态分配和动态分配；而堆置支持动态分配；

效率上：栈的效率比堆要高



# 不同jdk版本下intern()方法的区别

![image-20200728230135569](D:\backendLearning\ctoNote\mdSource\_posts\img\image-20200728230135569.png)

![image-20200728230321131](D:\backendLearning\ctoNote\mdSource\_posts\img\image-20200728230321131.png)

![image-20200728231002000](D:\backendLearning\ctoNote\mdSource\_posts\img\image-20200728231002000.png)