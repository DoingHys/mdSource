

[TOC]

# String

1. ***equal 与 == 的区别***

   equal是比较内容

   ```
   eg1：
   String a= new String ("abcd")；String b= new String("abcd")
   a.equal(b) ---->true  ;a==b  ---->为false
   ```

   ```
   eg2：
   String a="def"; String b="def";
   a.equal(b) ---->true  ;a==b  ---->true
   ```

   **图解 **

   ![image-20200213174408697](C:\Users\vinti\AppData\Roaming\Typora\typora-user-images\image-20200213174408697.png)

   

2. ***String.trim()***

   只是去除首尾的空格，中间空格无法去除

3. ***final value[] a***

   a 不可变，但是里面的元素（成员变量）是可变的；只是指向的地址没变

4. String 对象内存分析

   ```
   String gh= new String ("123")
   for(int i=0;i<100;i++){
   	gh=gh+1;
   }
   //这段代码会生成102个对象
   对象1：”123” 对象2：new String(); 
   一般不建议这样追加字符串，尽量避免这样的代码
   ```

   

# Stringbuilder 与StringBuffer

* StringBuilder ：效率高，线程不安全

* StringBuffer：效率低，线程安全

* 共同点：

  new 会初始化字符数组长度为16,如果长度不够，会调用自动扩容方法

  reserve()：倒序字符排序



# 常用类自动装箱拆箱

1. 自动装箱：

   Interger a=1000;

   **编译器**会自动帮它 转化为 Integet a= new Integer(1000);

2. 自动拆箱

   int b = new Integet(1000);

   编译器改造：new Integer(15000).intValue();

3. 注意点：

   * 异常

     Integer b=null;

     int c= b;

     会报null指针异常，因为此过程会调用 b.intValue()方法

   * 值比较

     ```
     Integer a =1234;
     integer b=1234;
     sout(a==b)  结果为false ,因为是不同的对象
     sout(a.equal(b))结果为true，因为源码是比较值
     
     ########################
     Integer a =123;
     integer b=123;
     sout(a==b)  true  //[-128~127] 会被当做为基本数据类型处理
     sout(a.equal(b))结果为true，因为源码是比较值
     ```


# Date 类型

![image-20200216172442296](C:\Users\vinti\AppData\Roaming\Typora\typora-user-images\image-20200216172442296.png)

1. 注意点：

   月份：一月：0；十二月：11

   星期：周日是1，周六是7



# 异常简介

异常分为uncheck 异常和checked 异常，uncheck 异常（属于RuntimeException的一种） 

unchekedException:是指编译器不会去做检查的异常，是编译器不通过的，error是unchecked的，因为我们无法控制它，RuntimeException太频繁了，并且编译器也无法检查，因此需要手动捕获处理；

checkedExceptin:所有不是RuntimeException统称为checked 异常，此类异常不是程序本身引起，而是外界因素造成，是编译器通过的（已检查过的），不需要捕获处理；为了预防这些异常的产生，造成程序的中断或者结果的不正确，通常需要在编写可能产生这些异常的时候一定要去做异常的处理



1. catch捕获异常的顺序：

   如果异常类之间有继承关系，越是顶层的类越要放在下面。因为顶层的类会捕获底层的类的异常，再不然就把多余的catch省略掉

2. 异常处理返回顺序

   a.执行 try, catch ,返回值赋值

   b.执行finally

   c.return返回值 

   注意：如果finally return 会覆盖返回值

3. 方法重写中声明异常的原则

   子类声明的异常范围不能超过父类声明的异常范围：

   * 父类没有声明异常子类也不能声明
   * 不可抛出原有方法抛出异常的父类或上层类
   * 抛出的异常不可比原有方法的异常类型多（指类型而不是个数）



# 强转

Object a= 80；

int  b=(Interger) a;

Object-->Integer-->自动拆箱



# 泛型

泛型类：声明使用泛型

字母：

T Type表示类型

K V 分别代表键值中的Key Value

E 代表Element

使用时确定类型

注意:

1.泛型 只能使用引用类型，不能基本类型

2.泛型声明的时候不能使用静态属性或者静态方法

3.接口中泛型字母只能使用在方法中 不能使用做 全局常量

 4.只能访问对象信息，不能修改

5.泛型没有堕胎

  

# comparable排序工具

整数，小数，integer,double,flloat 比较的是基本数据类型的大小

String类型：是比较返回长度之差

字符：是比较unicode码之差



1.实体类  java.util.Comparable+comporeTo

2.业务排序类  java.util.Comparator+compare

功能：

解耦：与实体类分类

方便：应对多变的排序规则

# 基本数据类型

![img](https://pics1.baidu.com/feed/bf096b63f6246b6015db52b41e227f48530fa27c.jpeg?token=11ed133dbdb289d94fde6686ca284a2f&s=BDA87C339F0B604B4ADD45DB000080B1)

# java 位操作

1、位操作运算符的种类：&（与）、|（或）、~（取反）、^（异或）、<<（左移）、>>（右移）、>>>（无符号右移）。

[注]Java中不存在<<<。

2、位运算符操作不会短路。

3、位运算符操作的是补码，所以~后正负号会发生变化。

4、位运算符只能用于整型。

5、反码、补码是相对于有符号数而言的，且不改变符号位。无符号数没有反码、补码。

其中移位运算符需要注意的地方：

三个移位运算符的相同点：当移位的位数超出数值的位数则会取模后再移位。

 ## 位移

（1）m>>>n：整数m表示的二进制右移n位，不论正负数，高位都补零。 **逻辑右移 无符号右移**

```
3>>>2剖析：
  3二进制形式: 00000000 00000000 00000000 00000011,按照$3的原理，得到00000000 00000000 00000000 00000000,即为0.
  -3>>>2剖析：
  -3二进制形式: 11111111 11111111 11111111 11111101,按照$3的原理，得到00111111 11111111 11111111 11111111,即为1073741823.
   
```

(2) m>>n的含义:把整数m表示的二进制数右移n位,m为正数，高位全部补0；m为负数，高位全部补1. **算术右移 有符号右移**

```
3>>2剖析：
  3二进制形式: 00000000 00000000 00000000 00000011,按照$2的原理，得到00000000 00000000 00000000 00000000,即为0.
  -3>>2剖析：
  -3二进制形式: 11111111 11111111 11111111 11111101,按照$2的原理，得到11111111 11111111 11111111 11111111,即为-1.

以上:每 个整数表示的二进制都是32位的，如果右移32位和右移0位的效果是一样的。依次类推，右移32的倍数位都一样。

备注:对于右移32位与右移0位是结果是一样的，我一直不能够理解。现在我只能理解为32比较特殊。相当于整体全移。与移0位相同。左移也是一样的
```

(3)左移一位：相当于乘2，右移一位相当于除2

(4）关于左右移

0. m<<n即在数字没有溢出的前提下，对于正数和负数，左移n位都相当于m乘以2的n次方.

1. m>>n即相当于m除以2的n次方，得到的为整数时，即为结果。如果结果为小数，此时会出现两种情况：(1)如果m为正数，得到的商会无条件 的舍弃小数位；(2)如果m为负数，舍弃小数部分，然后把整数部分加+1得到位移后的值。

**位移得好处**：

```
接 下来在此说说位操作的好处，速度超快，这些都是底层的二进制机器操作指令。
  比如:a*2，

       1.jvm先为变量a分配空间；
       2.再进行a*2的操作；
      3.再把结果返回给相应的变量。
```

##  **~(按位非)，|(按位或)，&(按位与)，^(按位异或)，**

1.~(按位非):【解义】对该整数的二进制形 式逐位取反。
  ~4：(一元操作符)
   4的二进制形式为：00000000 00000000 00000000 00000100，逐位取反后得

到:11111111 11111111 11111111 11111011,即为-5.



2.| (按位或):【解义】对两个整数的二进制形式逐位进行逻辑或运算，原理为:1|0=1,0|0=0,1|1=1,0|1=1
等。
  4|-5：
   4的二进制形式为：00000000 00000000 00000000 00000100，
  -5的二进制形式为：11111111 11111111 11111111 11111011，
 逐位进行逻辑或运算：11111111 11111111 11111111 11111111，即得到-1.



3.&(按位与):【解义】对两个整数的二进制形式逐位进行逻辑与 运算，原理:1&0=0,0&0=0,1&1=1;0&1=0等。 
  4&-5：
   4的二进制形式为：00000000 00000000 00000000 00000100，
  -5的二进制形式为：11111111 11111111 11111111 11111011，
 逐位进行逻辑与运算：00000000 00000000 00000000 00000000,即得到0. 

实际应用：可以把字节转换为整 数，-64&0xFF=192,也可以用八进制的形式，-64&0377=192



4.^(按 位异或):【解义】对两个整数的二进制形式逐位进行逻辑异或运算，原理:1^1=0,1^0=1,0^1=1,0^0=0.
  4^-5：
   4的二进制形式为：00000000 00000000 00000000 00000100，
  -5的二进制形式为：11111111 11111111 11111111 11111011，
逐位进行逻辑异或运算：11111111 11111111 11111111 11111111，即得到-1. 

实际应用：按位异或可以比较两个数字是否相等，它利用 1^1=0，0^0=0的原理。 20^20==0 



# 进制转换

其实0xFF和0377都表示的是整数255

**二进制:**

有两个特点：它由两个数码0，1组成，二进制数运算规律是逢二进一。

**十六进制:**

它由十六个数码：数字0～9加上字母A-F组成（它们分别表示十进制数10～15），十六进制数运算规律是逢十六进一，即基数R=16=2^4，通常在表示时用尾部标志H或下标16以示区别，在c语言中用添加前缀0x以表示十六进制数。

以0x开始的数据表示16进制，0x[ff](https://www.baidu.com/s?wd=ff&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)换成十进制为255。

**关于负数得二进制表示**

例如 －5  
第一步：首先要把5变成101的二进制形式
第二步：再者就是按位取反，（形 成前面全是1）010
第三步：在最后加1 形成：11111111 11111111 11111111 11111011

# 抽象与接口类区别

1. 接口所有方法默认都是public,并且所有自定义方法在接口中不能有方法体，Java 8 开始接口方法可以有默认实现，抽象类可以有非抽象得方法
2. 接口类定义的变量都是final，而抽象类则不一定
3. 一个类可以实现多个接口，但最多只能实现一个抽象类（对于抽象类得实现相当于extends）
4.  一个类实现接口的话要实现接口的所有方法，而抽象类不一定,抽象类可以实现接口的部分方法
5. 当一个抽象类实现了一个接口，该接口有两个方法，此时抽象类实现了方法2，那么当再定义一个类A时，该类实现抽象类时必须实现零一个方法1，总结来说就是，**当要实现抽象类得时候，必须实现抽象类得所有未被实现的抽象方法**
6.  接口不 能用 new 实例化，但可以声明，但是必须引用一个实现该接口的对象 从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范
7. 在JDK8中，接口也可以定义静态方法，可以直接用接口名调用，实现类和实现是不可以调用的。





# 获取用键盘输入的两种常见方法

**方法一：**通过scanner

```
Scanner in= new Scanner(System.in);
String a= in.nextLine();
in.close();
```

**方法二**：通过BufferedReader

```
BufferedReader input = new BufferedReader(new InputStreamReader(System.in));

String a=input.readLine();
```



# java 变量的分类

1. 按被声明的位置划分

   局部变量：方法和语句块中定义的变量（定义局部变量时，必须对其进行初始化）

   成员变量：方法外部，类的内部定义的变量（成员变量可以是java语言中的任何一种数据类型）

   类由成员变量和成员方法构成。而成员变量又分为实例变量和类变量,类变量是由static修饰的变量；

   在同一个jvm中，每个类只对应一个Class对象，但是每个类可以创建多个java对象。由于在同一个JVM内，每个类只对应一个Class对象，因此同一个jvm内的一个类的变量只需要一块内存空间；但对于实例变量而言，该类每创建一次实例，就需要为它分配一块内存空间。也就是说，程序中有几个实例，实例变量就需要几块内存空间